-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/YaccConstructor/LangToGroup#readme</a>
@package LangToGroup
@version 0.1.0.0

module Boolean2TMConstants
minus :: [Char]
plus :: [Char]
signs :: [[Char]]
negation :: [Char]
leftBracket :: [Char]
rightBracket :: [Char]
brackets :: [[Char]]
hash :: [Char]
star :: [Char]
space :: [Char]
comma :: [Char]


-- | Module <a>Map</a> just export realisation of <a>Map</a>.
module Containers.Map


-- | Module <a>Pair</a> include type <a>Pair</a> and useful functions for
--   work with it.
--   
--   `Pair a` is just pair as `(a, a)`.
module Containers.Pair
newtype Pair a
Pair :: (a, a) -> Pair a
unPair :: Pair a -> (a, a)
first :: Pair a -> a
second :: Pair a -> a
swap :: Pair a -> Pair a
toList :: Pair a -> [a]
toZipList :: Pair a -> ZipList a
fromList :: MonadFail m => [a] -> m (Pair a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Containers.Pair.Pair a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Containers.Pair.Pair a)
instance Control.Lens.Each.Each (Containers.Pair.Pair a) (Containers.Pair.Pair b) a b
instance GHC.Base.Functor Containers.Pair.Pair
instance GHC.Base.Applicative Containers.Pair.Pair
instance Data.Foldable.Foldable Containers.Pair.Pair
instance Data.Traversable.Traversable Containers.Pair.Pair


-- | Module <a>Quadruple</a> include type <a>Quadruple</a> and useful
--   functions for work with it.
--   
--   `Quadruple a` is just quadruple as `(a, a, a, a)`.
module Containers.Quadruple
newtype Quadruple a
Quadruple :: (a, a, a, a) -> Quadruple a
unQuadruple :: Quadruple a -> (a, a, a, a)
toList :: Quadruple a -> [a]
toZipList :: Quadruple a -> ZipList a
fromList :: MonadFail m => [a] -> m (Quadruple a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Containers.Quadruple.Quadruple a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Containers.Quadruple.Quadruple a)
instance GHC.Base.Functor Containers.Quadruple.Quadruple
instance GHC.Base.Applicative Containers.Quadruple.Quadruple
instance Data.Foldable.Foldable Containers.Quadruple.Quadruple
instance Data.Traversable.Traversable Containers.Quadruple.Quadruple


-- | Module <a>Set</a> just export realisation of <a>Set</a>.
module Containers.Set


-- | Module <a>Iso</a> include class <a>Iso</a> for realisation of
--   isomorphism.
module Containers.IsoMap.Iso
class Iso i a b | i a -> b, i b -> a
(~$) :: (Iso i a b, MonadFail m) => i -> a -> m b
(~&) :: (Iso i a b, MonadFail m) => a -> i -> m b
values :: Iso i a b => i -> Set a
member :: Iso i a b => a -> i -> Bool
filter :: Iso i a b => (a -> Bool) -> i -> i
insert :: (Iso i a b, MonadFail m) => (a, b) -> i -> m i
delete :: Iso i a b => a -> i -> i
toMap :: Iso i a b => i -> Map a b
fromList :: (Iso i a b, MonadFail m) => [(a, b)] -> m i
fromList' :: Iso i a b => [(a, b)] -> i
toList :: Iso i a b => i -> [(a, b)]
singleton :: Iso i a b => a -> b -> i
infixr 1 ~$
infixr 1 ~&


-- | Module <a>IsoMap</a> include type <a>IsoMap</a> and useful functions
--   for working with it.
--   
--   <a>IsoMap</a> is kind of <a>Map</a> with isomorphism between keys and
--   values. So, difference between keys ans values is erased, and you can
--   use as keys any of two available sets, and other set will be used as
--   values.
module Containers.IsoMap
data IsoMap a b
size :: IsoMap a b -> Int
empty :: IsoMap a b
mapFst :: Ord b => (a -> b) -> IsoMap a c -> IsoMap b c
mapSnd :: Ord b => (a -> b) -> IsoMap c a -> IsoMap c b
mapFstRev :: Ord b => (a -> b) -> IsoMap a c -> IsoMap c b
mapSndRev :: Ord b => (a -> b) -> IsoMap c a -> IsoMap b c
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Containers.IsoMap.IsoMap a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Containers.IsoMap.IsoMap a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.IsoMap.Iso.Iso (Containers.IsoMap.IsoMap a b) a b
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.IsoMap.Iso.Iso (Containers.IsoMap.IsoMap a b) b a


-- | Module <a>Format</a> include types of so called "formats" and methods
--   for work with them.
--   
--   Format is object for simple pattern matching and generating strings by
--   template.
module Format
data SimpleFormat
data TaggedFormat
data MultiFormat
data MaybeFormat f
JustFormat :: f -> MaybeFormat f
JustString :: String -> MaybeFormat f
isFormat :: MaybeFormat f -> Bool
type MaybeSimpleFormat = MaybeFormat SimpleFormat
type MaybeTaggedFormat = MaybeFormat TaggedFormat
format :: (Format f, MonadFail m) => String -> m f
apply :: Apply f i => f -> i -> String
format2str :: Apply f () => f -> String
match :: Match f r => f -> String -> r
instance Format.Match Format.SimpleFormat GHC.Types.Bool
instance Control.Monad.Fail.MonadFail m => Format.Match Format.SimpleFormat (m GHC.Base.String)
instance Format.Match Format.SimpleFormat a => Format.Match Format.TaggedFormat a
instance Format.Match Format.MultiFormat (GHC.Maybe.Maybe [GHC.Base.String])
instance Format.Match Format.MultiFormat GHC.Types.Bool
instance Format.Match f GHC.Types.Bool => Format.Match (Format.MaybeFormat f) GHC.Types.Bool
instance (Control.Monad.Fail.MonadFail m, Format.Match f (m GHC.Base.String)) => Format.Match (Format.MaybeFormat f) (m GHC.Base.String)
instance Format.Apply Format.SimpleFormat GHC.Base.String
instance Format.Apply Format.TaggedFormat GHC.Base.String
instance Format.Apply Format.TaggedFormat ()
instance Format.Apply Format.MultiFormat [GHC.Base.String]
instance Format.Apply f i => Format.Apply (Format.MaybeFormat f) i
instance Format.Format Format.SimpleFormat
instance Format.Format Format.TaggedFormat
instance Format.Format Format.MultiFormat
instance Format.Format f => Format.Format (Format.MaybeFormat f)


-- | This module represents types of formal grammar.
--   
--   In the moment we use it to represent a context-free grammar,
--   conjunctive grammar, boolean grammar.
module GrammarType

-- | <a>Terminal</a> is a type that represents terminal in the formal
--   grammar <a>Grammar</a>.
newtype Terminal
Terminal :: String -> Terminal
[terminalValue] :: Terminal -> String

-- | <a>Nonterminal</a> is a type that represents nonterminal in the formal
--   grammar <a>Grammar</a>.
newtype Nonterminal
Nonterminal :: String -> Nonterminal
[nonterminalValue] :: Nonterminal -> String

-- | <a>Symbol</a> represents symbol that can be appear in right part of
--   the <a>Relation</a>.
--   
--   <a>T</a> is for <a>Terminal</a>.
--   
--   <a>N</a> is for <a>Nonterminal</a>.
--   
--   And <a>Eps</a> is for empty symbol, epsilon.
data Symbol
T :: Terminal -> Symbol
N :: Nonterminal -> Symbol
Eps :: Symbol

-- | Conj is helper type for representing the right part of a relation in a
--   boolean grammar
data Conj
PosConj :: [Symbol] -> Conj
[symbols] :: Conj -> [Symbol]
NegConj :: [Symbol] -> Conj
[symbols] :: Conj -> [Symbol]

-- | This type is synonym <a>Nonterminal</a> and used in order to separate
--   <a>StartSymbol</a> from normal <a>Nonterminal</a>.
type StartSymbol = Nonterminal

-- | <a>Relation</a> is a rule of <a>Grammar</a>. First constructor is for
--   working only with CFG grammars Second constructor is for working with
--   Boolean or Conjunctive grammars, though it might be used for defining
--   grammars too (right part of CFG relation is one PosConj in right part
--   of boolean relation)
data Relation
Relation :: (Nonterminal, [Symbol]) -> Relation
BooleanRelation :: (Nonterminal, [Conj]) -> Relation

-- | This type we using to classify grammars.
data GrammarType
CFG :: GrammarType
Conjunctive :: GrammarType
Boolean :: GrammarType

-- | This type we using to represent a formal grammar.
newtype Grammar
Grammar :: (Set Nonterminal, Set Terminal, Set Relation, StartSymbol) -> Grammar
instance GHC.Show.Show GrammarType.Terminal
instance GHC.Classes.Ord GrammarType.Terminal
instance GHC.Classes.Eq GrammarType.Terminal
instance GHC.Show.Show GrammarType.Nonterminal
instance GHC.Classes.Ord GrammarType.Nonterminal
instance GHC.Classes.Eq GrammarType.Nonterminal
instance GHC.Show.Show GrammarType.Symbol
instance GHC.Classes.Ord GrammarType.Symbol
instance GHC.Classes.Eq GrammarType.Symbol
instance GHC.Show.Show GrammarType.Conj
instance GHC.Classes.Ord GrammarType.Conj
instance GHC.Classes.Eq GrammarType.Conj
instance GHC.Show.Show GrammarType.Relation
instance GHC.Classes.Ord GrammarType.Relation
instance GHC.Classes.Eq GrammarType.Relation
instance GHC.Show.Show GrammarType.GrammarType
instance GHC.Classes.Ord GrammarType.GrammarType
instance GHC.Classes.Eq GrammarType.GrammarType
instance GHC.Show.Show GrammarType.Grammar
instance GHC.Classes.Ord GrammarType.Grammar
instance GHC.Classes.Eq GrammarType.Grammar

module GroupPresentation.Generator
data Generator
generator :: Int -> Generator
numGenerator :: Generator -> Int
type GWord = [Generator]
instance GHC.Enum.Enum GroupPresentation.Generator.Generator
instance GHC.Classes.Ord GroupPresentation.Generator.Generator
instance GHC.Classes.Eq GroupPresentation.Generator.Generator
instance GHC.Enum.Bounded GroupPresentation.Generator.Generator

module GroupPresentation.Element
data Signed a
Positive :: a -> Signed a
[unSigned] :: Signed a -> a
Negative :: a -> Signed a
[unSigned] :: Signed a -> a
type Element = Signed Generator
element :: Int -> Element
(^~) :: Signed a -> Signed a
infix 9 ^~
isPositive :: Signed a -> Bool
getGenerator :: Element -> Generator
type EWord = [Element]
instance GHC.Classes.Ord a => GHC.Classes.Ord (GroupPresentation.Element.Signed a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (GroupPresentation.Element.Signed a)
instance GHC.Base.Functor GroupPresentation.Element.Signed
instance GHC.Base.Applicative GroupPresentation.Element.Signed
instance Data.Foldable.Foldable GroupPresentation.Element.Signed
instance Data.Traversable.Traversable GroupPresentation.Element.Signed


-- | Module <tt>Lens</tt> include the most common objects for working with
--   lenses.
module Lens

-- | A <a>Getter</a> describes how to retrieve a single value in a way that
--   can be composed with other <a>LensLike</a> constructions.
--   
--   Unlike a <a>Lens</a> a <a>Getter</a> is read-only. Since a
--   <a>Getter</a> cannot be used to write back there are no <a>Lens</a>
--   laws that can be applied to it. In fact, it is isomorphic to an
--   arbitrary function from <tt>(s -&gt; a)</tt>.
--   
--   Moreover, a <a>Getter</a> can be used directly as a <a>Fold</a>, since
--   it just ignores the <a>Applicative</a>.
type Getter s a = forall (f :: Type -> Type). (Contravariant f, Functor f) => a -> f a -> s -> f s

-- | When you see this in a type signature it indicates that you can pass
--   the function a <a>Lens</a>, <a>Getter</a>, <a>Traversal</a>,
--   <a>Fold</a>, <a>Prism</a>, <a>Iso</a>, or one of the indexed variants,
--   and it will just "do the right thing".
--   
--   Most <a>Getter</a> combinators are able to be used with both a
--   <a>Getter</a> or a <a>Fold</a> in limited situations, to do so, they
--   need to be monomorphic in what we are going to extract with
--   <a>Const</a>. To be compatible with <a>Lens</a>, <a>Traversal</a> and
--   <a>Iso</a> we also restricted choices of the irrelevant <tt>t</tt> and
--   <tt>b</tt> parameters.
--   
--   If a function accepts a <tt><a>Getting</a> r s a</tt>, then when
--   <tt>r</tt> is a <a>Monoid</a>, then you can pass a <a>Fold</a> (or
--   <a>Traversal</a>), otherwise you can only pass this a <a>Getter</a> or
--   <a>Lens</a>.
type Getting r s a = a -> Const r a -> s -> Const r s

-- | The only <a>LensLike</a> law that can apply to a <a>Setter</a>
--   <tt>l</tt> is that
--   
--   <pre>
--   <a>set</a> l y (<a>set</a> l x a) ≡ <a>set</a> l y a
--   </pre>
--   
--   You can't <a>view</a> a <a>Setter</a> in general, so the other two
--   laws are irrelevant.
--   
--   However, two <a>Functor</a> laws apply to a <a>Setter</a>:
--   
--   <pre>
--   <a>over</a> l <a>id</a> ≡ <a>id</a>
--   <a>over</a> l f <a>.</a> <a>over</a> l g ≡ <a>over</a> l (f <a>.</a> g)
--   </pre>
--   
--   These can be stated more directly:
--   
--   <pre>
--   l <a>pure</a> ≡ <a>pure</a>
--   l f <a>.</a> <a>untainted</a> <a>.</a> l g ≡ l (f <a>.</a> <a>untainted</a> <a>.</a> g)
--   </pre>
--   
--   You can compose a <a>Setter</a> with a <a>Lens</a> or a
--   <a>Traversal</a> using (<a>.</a>) from the <tt>Prelude</tt> and the
--   result is always only a <a>Setter</a> and nothing more.
--   
--   <pre>
--   &gt;&gt;&gt; over traverse f [a,b,c,d]
--   [f a,f b,f c,f d]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over _1 f (a,b)
--   (f a,b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse._1) f [(a,b),(c,d)]
--   [(f a,b),(f c,d)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both f (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (traverse.both) f [(a,b),(c,d)]
--   [(f a,f b),(f c,f d)]
--   </pre>
type Setter s t a b = forall (f :: Type -> Type). Settable f => a -> f b -> s -> f t

-- | Running a <a>Setter</a> instantiates it to a concrete type.
--   
--   When consuming a setter directly to perform a mapping, you can use
--   this type, but most user code will not need to use this type.
type ASetter s t a b = a -> Identity b -> s -> Identity t

-- | <pre>
--   type <a>Traversal'</a> = <a>Simple</a> <a>Traversal</a>
--   </pre>
type Traversal' s a = Traversal s s a a

-- | View the value pointed to by a <a>Getter</a> or <a>Lens</a> or the
--   result of folding over all the results of a <a>Fold</a> or
--   <a>Traversal</a> that points at a monoidal values.
--   
--   This is the same operation as <a>view</a> with the arguments flipped.
--   
--   The fixity and semantics are such that subsequent field accesses can
--   be performed with (<a>.</a>).
--   
--   <pre>
--   &gt;&gt;&gt; (a,b)^._2
--   b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^._2
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Complex
--   
--   &gt;&gt;&gt; ((0, 1 :+ 2), 3)^._1._2.to magnitude
--   2.23606797749979
--   </pre>
--   
--   <pre>
--   (<a>^.</a>) ::             s -&gt; <a>Getter</a> s a     -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Fold</a> s m       -&gt; m
--   (<a>^.</a>) ::             s -&gt; <a>Iso'</a> s a       -&gt; a
--   (<a>^.</a>) ::             s -&gt; <a>Lens'</a> s a      -&gt; a
--   (<a>^.</a>) :: <a>Monoid</a> m =&gt; s -&gt; <a>Traversal'</a> s m -&gt; m
--   </pre>
(^.) :: s -> Getting a s a -> a
infixl 8 ^.

-- | Build an (index-preserving) <a>Getter</a> from an arbitrary Haskell
--   function.
--   
--   <pre>
--   <a>to</a> f <a>.</a> <a>to</a> g ≡ <a>to</a> (g <a>.</a> f)
--   </pre>
--   
--   <pre>
--   a <a>^.</a> <a>to</a> f ≡ f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; a ^.to f
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.to snd
--   "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5^.to succ
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (0, -5)^._2.to abs
--   5
--   </pre>
--   
--   <pre>
--   <a>to</a> :: (s -&gt; a) -&gt; <a>IndexPreservingGetter</a> s a
--   </pre>
to :: (Profunctor p, Contravariant f) => (s -> a) -> Optic' p f s a

-- | View the value pointed to by a <a>Getter</a>, <a>Iso</a> or
--   <a>Lens</a> or the result of folding over all the results of a
--   <a>Fold</a> or <a>Traversal</a> that points at a monoidal value.
--   
--   <pre>
--   <a>view</a> <a>.</a> <a>to</a> ≡ <a>id</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to f) a
--   f a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view _2 (1,"hello")
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (to succ) 5
--   6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (_2._1) ("hello",("world","!!!"))
--   "world"
--   </pre>
--   
--   As <a>view</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>view</a> ::             <a>Getter</a> s a     -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s m       -&gt; s -&gt; m
--   <a>view</a> ::             <a>Iso'</a> s a       -&gt; s -&gt; a
--   <a>view</a> ::             <a>Lens'</a> s a      -&gt; s -&gt; a
--   <a>view</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s m -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Fold</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>view</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>view</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> a) =&gt; <a>Traversal'</a> s a -&gt; m a
--   </pre>
view :: MonadReader s m => Getting a s a -> m a

-- | View a function of the value pointed to by a <a>Getter</a> or
--   <a>Lens</a> or the result of folding over the result of mapping the
--   targets of a <a>Fold</a> or <a>Traversal</a>.
--   
--   <pre>
--   <a>views</a> l f ≡ <a>view</a> (l <a>.</a> <a>to</a> f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views (to f) g a
--   g (f a)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; views _2 length (1,"hello")
--   5
--   </pre>
--   
--   As <a>views</a> is commonly used to access the target of a
--   <a>Getter</a> or obtain a monoidal summary of the targets of a
--   <a>Fold</a>, It may be useful to think of it as having one of these
--   more restricted signatures:
--   
--   <pre>
--   <a>views</a> ::             <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Fold</a> s a       -&gt; (a -&gt; m) -&gt; s -&gt; m
--   <a>views</a> ::             <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> ::             <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; s -&gt; r
--   <a>views</a> :: <a>Monoid</a> m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; m) -&gt; s -&gt; m
--   </pre>
--   
--   In a more general setting, such as when working with a <a>Monad</a>
--   transformer stack you can use:
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: <a>MonadReader</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>views</a> :: (<a>MonadReader</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>views</a> :: <a>MonadReader</a> s m =&gt; <a>Getting</a> r s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
views :: MonadReader s m => LensLike' (Const r :: Type -> Type) s a -> (a -> r) -> m r

-- | Use the target of a <a>Lens</a>, <a>Iso</a>, or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) (a,b)
--   a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; evalState (use _1) ("hello","world")
--   "hello"
--   </pre>
--   
--   <pre>
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s r       -&gt; m r
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; m a
--   <a>use</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; m a
--   <a>use</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s r -&gt; m r
--   </pre>
use :: MonadState s m => Getting a s a -> m a

-- | Use the target of a <a>Lens</a>, <a>Iso</a> or <a>Getter</a> in the
--   current state, or use a summary of a <a>Fold</a> or <a>Traversal</a>
--   that points to a monoidal value.
--   
--   <pre>
--   &gt;&gt;&gt; evalState (uses _1 length) ("hello","world")
--   5
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Getter</a> s a     -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Fold</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: <a>MonadState</a> s m             =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; r) -&gt; m r
--   <a>uses</a> :: (<a>MonadState</a> s m, <a>Monoid</a> r) =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   <pre>
--   <a>uses</a> :: <a>MonadState</a> s m =&gt; <a>Getting</a> r s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
uses :: MonadState s m => LensLike' (Const r :: Type -> Type) s a -> (a -> r) -> m r

-- | Modifies the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a user supplied function.
--   
--   This is an infix version of <a>over</a>.
--   
--   <pre>
--   <a>fmap</a> f ≡ <a>mapped</a> <a>%~</a> f
--   <a>fmapDefault</a> f ≡ <a>traverse</a> <a>%~</a> f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c) &amp; _3 %~ f
--   (a,b,f c)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both %~ f
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 %~ length $ (1,"hello")
--   (1,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ f $ [a,b,c]
--   [f a,f b,f c]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse %~ even $ [1,2,3]
--   [False,True,False]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverse.traverse %~ length $ [["hello","world"],["!!!"]]
--   [[5,5],[3]]
--   </pre>
--   
--   <pre>
--   (<a>%~</a>) :: <a>Setter</a> s t a b    -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Iso</a> s t a b       -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Lens</a> s t a b      -&gt; (a -&gt; b) -&gt; s -&gt; t
--   (<a>%~</a>) :: <a>Traversal</a> s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Map over the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 %= f;_2 %= g) (a,b)
--   (f a,g b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (do both %= f) (a,b)
--   (f a,f b)
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; (a -&gt; a) -&gt; m ()
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; (a -&gt; a) -&gt; m ()
--   </pre>
--   
--   <pre>
--   (<a>%=</a>) :: <a>MonadState</a> s m =&gt; <a>ASetter</a> s s a b -&gt; (a -&gt; b) -&gt; m ()
--   </pre>
(%=) :: MonadState s m => ASetter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> with a constant value.
--   
--   This is an infix version of <a>set</a>, provided for consistency with
--   (<a>.=</a>).
--   
--   <pre>
--   f <a>&lt;$</a> a ≡ <a>mapped</a> <a>.~</a> f <a>$</a> a
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b,c,d) &amp; _4 .~ e
--   (a,b,c,e)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (42,"world") &amp; _1 .~ "hello"
--   ("hello","world")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (a,b) &amp; both .~ c
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.~</a>) :: <a>Setter</a> s t a b    -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Iso</a> s t a b       -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Lens</a> s t a b      -&gt; b -&gt; s -&gt; t
--   (<a>.~</a>) :: <a>Traversal</a> s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | Replace the target of a <a>Lens</a> or all of the targets of a
--   <a>Setter</a> or <a>Traversal</a> in our monadic state with a new
--   value, irrespective of the old.
--   
--   This is an infix version of <a>assign</a>.
--   
--   <pre>
--   &gt;&gt;&gt; execState (do _1 .= c; _2 .= d) (a,b)
--   (c,d)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; execState (both .= c) (a,b)
--   (c,c)
--   </pre>
--   
--   <pre>
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Iso'</a> s a       -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Lens'</a> s a      -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Traversal'</a> s a -&gt; a -&gt; m ()
--   (<a>.=</a>) :: <a>MonadState</a> s m =&gt; <a>Setter'</a> s a    -&gt; a -&gt; m ()
--   </pre>
--   
--   <i>It puts the state in the monad or it gets the hose again.</i>
(.=) :: MonadState s m => ASetter s s a b -> b -> m ()
infix 4 .=

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2)^._1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 .~ "hello" $ (1,2)
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 +~ 41
--   (42,2,3,4,5)
--   </pre>
--   
--   <pre>
--   <a>_1</a> :: <a>Lens</a> (a,b) (a',b) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c) (a',b,c) a a'
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d) (a',b,c,d) a a'
--   ...
--   <a>_1</a> :: <a>Lens</a> (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 *~ 3
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _2 print (1,2)
--   2
--   (1,())
--   </pre>
--   
--   <pre>
--   <a>anyOf</a> <a>_2</a> :: (s -&gt; <a>Bool</a>) -&gt; (a, s) -&gt; <a>Bool</a>
--   <a>traverse</a> <a>.</a> <a>_2</a> :: (<a>Applicative</a> f, <a>Traversable</a> t) =&gt; (a -&gt; f b) -&gt; t (s, a) -&gt; f (t (s, b))
--   <a>foldMapOf</a> (<a>traverse</a> <a>.</a> <a>_2</a>) :: (<a>Traversable</a> t, <a>Monoid</a> m) =&gt; (s -&gt; m) -&gt; t (b, s) -&gt; m
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Traverse both parts of a <a>Bitraversable</a> container with matching
--   types.
--   
--   Usually that type will be a pair. Use <a>each</a> to traverse the
--   elements of arbitrary homogeneous tuples.
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; both *~ 10
--   (10,20)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over both length ("hello","world")
--   (5,5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("hello","world")^.both
--   "helloworld"
--   </pre>
--   
--   <pre>
--   <a>both</a> :: <a>Traversal</a> (a, a)       (b, b)       a b
--   <a>both</a> :: <a>Traversal</a> (<a>Either</a> a a) (<a>Either</a> b b) a b
--   </pre>
both :: forall (r :: Type -> Type -> Type) a b. Bitraversable r => Traversal (r a a) (r b b) a b

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: a -> (a -> b) -> b
infixl 1 &

-- | Build lenses (and traversals) with a sensible default configuration.
--   
--   <i>e.g.</i>
--   
--   <pre>
--   data FooBar
--     = Foo { _x, _y :: <a>Int</a> }
--     | Bar { _x :: <a>Int</a> }
--   <a>makeLenses</a> ''FooBar
--   </pre>
--   
--   will create
--   
--   <pre>
--   x :: <a>Lens'</a> FooBar <a>Int</a>
--   x f (Foo a b) = (\a' -&gt; Foo a' b) &lt;$&gt; f a
--   x f (Bar a)   = Bar &lt;$&gt; f a
--   y :: <a>Traversal'</a> FooBar <a>Int</a>
--   y f (Foo a b) = (\b' -&gt; Foo a  b') &lt;$&gt; f b
--   y _ c@(Bar _) = pure c
--   </pre>
--   
--   <pre>
--   <a>makeLenses</a> = <a>makeLensesWith</a> <a>lensRules</a>
--   </pre>
makeLenses :: Name -> DecsQ

-- | <tt><a>on</a> b u x y</tt> runs the binary function <tt>b</tt>
--   <i>on</i> the results of applying unary function <tt>u</tt> to two
--   arguments <tt>x</tt> and <tt>y</tt>. From the opposite perspective, it
--   transforms two inputs and combines the outputs.
--   
--   <pre>
--   ((+) `<a>on</a>` f) x y = f x + f y
--   </pre>
--   
--   Typical usage: <tt><a>sortBy</a> (<a>compare</a> `on`
--   <a>fst</a>)</tt>.
--   
--   Algebraic properties:
--   
--   <ul>
--   <li><pre>(*) `on` <a>id</a> = (*) -- (if (*) ∉ {⊥, <a>const</a>
--   ⊥})</pre></li>
--   <li><pre>((*) `on` f) `on` g = (*) `on` (f . g)</pre></li>
--   <li><pre><a>flip</a> on f . <a>flip</a> on g = <a>flip</a> on (g .
--   f)</pre></li>
--   </ul>
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
infixl 0 `on`


-- | Module <a>PrismMap</a> include type <a>PrismMap</a> and useful
--   functions for working with it.
--   
--   <a>PrismMap</a> is kind of <a>Map</a> with faster access to keys by
--   value. So, it is almost <tt>IsoMap</tt>, but without isomorphism
--   restriction.
module Containers.PrismMap
data PrismMap k a
size :: PrismMap k a -> Int
null :: PrismMap k a -> Bool
empty :: PrismMap k a
singleton :: k -> a -> PrismMap k a
fromList :: (Ord k, Ord a) => [(k, a)] -> PrismMap k a
toList :: PrismMap k a -> [(k, a)]
toMap :: PrismMap k a -> Map k a
lookup :: (Ord k, MonadFail m) => k -> PrismMap k a -> m a
lookupKeys :: Ord a => a -> PrismMap k a -> Set k
values :: PrismMap k a -> [a]
keys :: PrismMap k a -> [k]
keysSet :: PrismMap k a -> Set k
value :: Ord a => a -> PrismMap k a -> Bool
key :: Ord k => k -> PrismMap k a -> Bool
map :: Ord b => (a -> b) -> PrismMap k a -> PrismMap k b
mapKeys :: Ord l => (k -> l) -> PrismMap k a -> PrismMap l a
filter :: (a -> Bool) -> PrismMap k a -> PrismMap k a
filterKeys :: (k -> Bool) -> PrismMap k a -> PrismMap k a
insert :: (Ord k, Ord a) => k -> a -> PrismMap k a -> PrismMap k a
deleteKey :: (Ord k, Ord a, MonadFail m) => k -> PrismMap k a -> m (PrismMap k a)
deleteValue :: (Ord k, Ord a, MonadFail m) => a -> PrismMap k a -> m (PrismMap k a)
union :: (Ord k, Ord a) => PrismMap k a -> PrismMap k a -> PrismMap k a
intersection :: (Ord k, Ord a) => PrismMap k a -> PrismMap k a -> PrismMap k a
difference :: (Ord k, Ord a) => PrismMap k a -> PrismMap k a -> PrismMap k a
instance (GHC.Classes.Eq k, GHC.Classes.Eq a) => GHC.Classes.Eq (Containers.PrismMap.PrismMap k a)
instance (GHC.Show.Show k, GHC.Show.Show a) => GHC.Show.Show (Containers.PrismMap.PrismMap k a)


-- | Module <tt>Containers</tt> include a lot of general methods for
--   working with containers. All methods are scattered by classes.
module Containers

-- | A set of values <tt>a</tt>.
data Set a

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a
data IsoMap a b
data PrismMap k a
newtype Pair a
Pair :: (a, a) -> Pair a
[unPair] :: Pair a -> (a, a)
newtype Quadruple a
Quadruple :: (a, a, a, a) -> Quadruple a
[unQuadruple] :: Quadruple a -> (a, a, a, a)
data Index
index :: Int -> Index
class Sizable c
size :: Sizable c => c -> Int
class Nullable c
nullC :: Nullable c => c -> Bool
nullC :: (Nullable c, Sizable c) => c -> Bool
emptyC :: Nullable c => c
class Singletonable c v | c -> v
singleton :: Singletonable c v => v -> c
class Valuable c v
values :: Valuable c v => c -> [v]
values :: (Valuable c v, Ord v) => c -> [v]
valuesSet :: (Valuable c v, Ord v) => c -> Set v
class Keyable c k | c -> k
keys :: Keyable c k => c -> [k]
keys :: (Keyable c k, Ord k) => c -> [k]
keysSet :: (Keyable c k, Ord k) => c -> Set k
class Indexable c k v | c k -> v, c v -> k
(!?) :: (Indexable c k v, MonadFail m) => c -> k -> m v
(!<>) :: Indexable c k v => c -> k -> Set v
(.@) :: (Indexable c k v, MonadFail m) => Getting x y c -> k -> Getting x y (m v)
(.<@>) :: Indexable c k v => Getting x y c -> k -> Getting x y (Set v)
infixl 9 !?
infixl 9 !<>
infixr 9 .@
infixr 9 .<@>
class Slicable c k
takeC :: Slicable c k => k -> c -> c
dropC :: Slicable c k => k -> c -> c
splitAtC :: Slicable c k => k -> c -> (c, c)
class Operable c
union :: Operable c => c -> c -> c
(\/) :: Operable c => c -> c -> c
(\/~) :: Operable c => ASetter s t c c -> c -> s -> t
(\/=) :: (Operable c, MonadState s m) => ASetter s s c c -> c -> m ()
intersection :: Operable c => c -> c -> c
(/\) :: Operable c => c -> c -> c
(/\~) :: Operable c => ASetter s t c c -> c -> s -> t
(/\=) :: (Operable c, MonadState s m) => ASetter s s c c -> c -> m ()
difference :: Operable c => c -> c -> c
(\\) :: Operable c => c -> c -> c
(\\~) :: Operable c => ASetter s t c c -> c -> s -> t
(\\=) :: (Operable c, MonadState s m) => ASetter s s c c -> c -> m ()
infixl 5 \\
infixl 5 \/
infixl 5 /\
infixr 4 \/~
infixr 4 /\~
infixr 4 \\~
infix 4 \/=
infix 4 /\=
infix 4 \\=
class Listable c v | c -> v
toList :: Listable c v => c -> [v]
toList :: (Listable c v, Valuable c v) => c -> [v]
fromList_ :: (Listable c v, MonadFail m) => [v] -> m c
fromList_ :: (Listable c v, UnsafeListable c v, MonadFail m) => [v] -> m c
class UnsafeListable c v | c -> v
fromList :: UnsafeListable c v => [v] -> c
class FastUnsafeListable c v | c -> v
fromAscList :: FastUnsafeListable c v => [v] -> c
fromDistinctAscList :: FastUnsafeListable c v => [v] -> c
fromDescList :: FastUnsafeListable c v => [v] -> c
fromDistinctDescList :: FastUnsafeListable c v => [v] -> c
class Containable c v
member :: Containable c v => v -> c -> Bool
notMember :: Containable c v => v -> c -> Bool
class Gunctor c1 c2 v1 v2 | c1 c2 -> v1 v2
gmap :: Gunctor c1 c2 v1 v2 => (v1 -> v2) -> c1 -> c2
(<@>) :: Gunctor c1 c2 v1 v2 => (v1 -> v2) -> c1 -> c2
infix 4 <@>
class Filterable c v
filterC :: Filterable c v => (v -> Bool) -> c -> c
(<?>) :: Filterable c v => (v -> Bool) -> c -> c
(<?>~) :: Filterable c v => ASetter s t c c -> (v -> Bool) -> s -> t
(<?>=) :: (Filterable c v, MonadState s m) => ASetter s s c c -> (v -> Bool) -> m ()
infix 4 <?>
infixr 4 <?>~
infix 4 <?>=
class Insertable c v
insert :: (Insertable c v, MonadFail m) => v -> c -> m c
insert :: (Insertable c v, Containable c v, MonadFail m) => v -> c -> m c
unsafeInsert :: Insertable c v => v -> c -> c
(+>) :: Insertable c v => v -> c -> c
(<+) :: Insertable c v => c -> v -> c
(<+~) :: Insertable c v => ASetter s t c c -> v -> s -> t
(<+=) :: (Insertable c v, MonadState s m) => ASetter s s c c -> v -> m ()
infixr 4 <+~
infix 4 <+=
infixr 7 +>
infixl 6 <+
class Deletable c v
delete :: (Deletable c v, MonadFail m) => v -> c -> m c
delete :: (Deletable c v, Containable c v, MonadFail m) => v -> c -> m c
unsafeDelete :: Deletable c v => v -> c -> c
(\>) :: Deletable c v => v -> c -> c
(<\) :: Deletable c v => c -> v -> c
(<\~) :: Deletable c v => ASetter s t c c -> v -> s -> t
(<\=) :: (Deletable c v, MonadState s m) => ASetter s s c c -> v -> m ()
infixr 7 \>
infixl 6 <\
infixr 4 <\~
infix 4 <\=
instance GHC.Enum.Enum Containers.Index
instance GHC.Num.Num Containers.Index
instance GHC.Classes.Ord Containers.Index
instance GHC.Classes.Eq Containers.Index
instance GHC.Classes.Eq a => Containers.Deletable [a] a
instance Containers.Deletable [a] Containers.Index
instance GHC.Classes.Ord a => Containers.Deletable (Data.Set.Internal.Set a) a
instance GHC.Classes.Ord k => Containers.Deletable (Data.Map.Internal.Map k a) k
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Deletable (Containers.IsoMap.IsoMap a b) a
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Deletable (Containers.IsoMap.IsoMap a b) b
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.Deletable (Containers.PrismMap.PrismMap k a) k
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.Deletable (Containers.PrismMap.PrismMap k a) a
instance Containers.Insertable [a] a
instance GHC.Classes.Ord a => Containers.Insertable (Data.Set.Internal.Set a) a
instance (GHC.Classes.Ord k, GHC.Classes.Eq a) => Containers.Insertable (Data.Map.Internal.Map k a) (k, a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Insertable (Containers.IsoMap.IsoMap a b) (a, b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Insertable (Containers.IsoMap.IsoMap a b) (b, a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.Insertable (Containers.PrismMap.PrismMap k a) (k, a)
instance Containers.Filterable [a] a
instance Containers.Filterable (Data.Set.Internal.Set a) a
instance Containers.Filterable (Data.Map.Internal.Map k a) k
instance Containers.Filterable (Data.Map.Internal.Map k a) a
instance Containers.Filterable (Data.Map.Internal.Map k a) (k, a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Filterable (Containers.IsoMap.IsoMap a b) a
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Filterable (Containers.IsoMap.IsoMap a b) b
instance Containers.Filterable (Containers.PrismMap.PrismMap k a) k
instance Containers.Filterable (Containers.PrismMap.PrismMap k a) a
instance GHC.Classes.Ord b => Containers.Gunctor (Data.Set.Internal.Set a) (Data.Set.Internal.Set b) a b
instance GHC.Classes.Ord l => Containers.Gunctor (Data.Map.Internal.Map k a) (Data.Map.Internal.Map l a) k l
instance Containers.Gunctor (Data.Map.Internal.Map k a) (Data.Map.Internal.Map k b) a b
instance GHC.Classes.Ord a2 => Containers.Gunctor (Containers.IsoMap.IsoMap a1 b) (Containers.IsoMap.IsoMap a2 b) a1 a2
instance GHC.Classes.Ord b2 => Containers.Gunctor (Containers.IsoMap.IsoMap a b1) (Containers.IsoMap.IsoMap a b2) b1 b2
instance GHC.Classes.Ord a2 => Containers.Gunctor (Containers.IsoMap.IsoMap a1 b) (Containers.IsoMap.IsoMap b a2) a1 a2
instance GHC.Classes.Ord b2 => Containers.Gunctor (Containers.IsoMap.IsoMap a b1) (Containers.IsoMap.IsoMap b2 a) b1 b2
instance GHC.Classes.Ord l => Containers.Gunctor (Containers.PrismMap.PrismMap k a) (Containers.PrismMap.PrismMap l a) k l
instance GHC.Classes.Ord b => Containers.Gunctor (Containers.PrismMap.PrismMap k a) (Containers.PrismMap.PrismMap k b) a b
instance GHC.Classes.Eq a => Containers.Containable [a] a
instance Containers.Containable [a] Containers.Index
instance GHC.Classes.Ord a => Containers.Containable (Data.Set.Internal.Set a) a
instance GHC.Classes.Ord k => Containers.Containable (Data.Map.Internal.Map k a) k
instance GHC.Classes.Eq a => Containers.Containable (Data.Map.Internal.Map k a) a
instance (GHC.Classes.Ord k, GHC.Classes.Eq a) => Containers.Containable (Data.Map.Internal.Map k a) (k, a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Containable (Containers.IsoMap.IsoMap a b) a
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Containable (Containers.IsoMap.IsoMap a b) b
instance GHC.Classes.Ord k => Containers.Containable (Containers.PrismMap.PrismMap k a) k
instance GHC.Classes.Ord a => Containers.Containable (Containers.PrismMap.PrismMap k a) a
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.Containable (Containers.PrismMap.PrismMap k a) (k, a)
instance GHC.Classes.Eq a => Containers.Containable (Containers.Pair.Pair a) a
instance GHC.Classes.Eq a => Containers.Containable (Containers.Quadruple.Quadruple a) a
instance GHC.Classes.Eq a => Containers.FastUnsafeListable (Data.Set.Internal.Set a) a
instance GHC.Classes.Eq k => Containers.FastUnsafeListable (Data.Map.Internal.Map k a) (k, a)
instance Containers.Listable [a] a
instance GHC.Classes.Ord a => Containers.Listable (Data.Set.Internal.Set a) a
instance GHC.Classes.Ord k => Containers.Listable (Data.Map.Internal.Map k a) (k, a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Listable (Containers.IsoMap.IsoMap a b) (a, b)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.Listable (Containers.PrismMap.PrismMap k a) (k, a)
instance Containers.Listable (Containers.Pair.Pair a) a
instance Containers.Listable (Containers.Quadruple.Quadruple a) a
instance Containers.UnsafeListable [a] a
instance GHC.Classes.Ord a => Containers.UnsafeListable (Data.Set.Internal.Set a) a
instance GHC.Classes.Ord k => Containers.UnsafeListable (Data.Map.Internal.Map k a) (k, a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.UnsafeListable (Containers.IsoMap.IsoMap a b) (a, b)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.UnsafeListable (Containers.PrismMap.PrismMap k a) (k, a)
instance GHC.Classes.Eq a => Containers.Operable [a]
instance GHC.Classes.Ord a => Containers.Operable (Data.Set.Internal.Set a)
instance GHC.Classes.Ord k => Containers.Operable (Data.Map.Internal.Map k a)
instance (GHC.Classes.Ord k, GHC.Classes.Ord a) => Containers.Operable (Containers.PrismMap.PrismMap k a)
instance Containers.Slicable [a] Containers.Index
instance Containers.Slicable [a] (a -> GHC.Types.Bool)
instance Containers.Slicable (Data.Set.Internal.Set a) Containers.Index
instance Containers.Slicable (Data.Set.Internal.Set a) (a -> GHC.Types.Bool)
instance Containers.Indexable [a] Containers.Index a
instance GHC.Classes.Eq a => Containers.Indexable [a] a Containers.Index
instance Containers.Indexable (Data.Set.Internal.Set a) Containers.Index a
instance GHC.Classes.Ord k => Containers.Indexable (Data.Map.Internal.Map k a) k a
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Indexable (Containers.IsoMap.IsoMap a b) a b
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Indexable (Containers.IsoMap.IsoMap a b) b a
instance GHC.Classes.Ord k => Containers.Indexable (Containers.PrismMap.PrismMap k a) k a
instance GHC.Classes.Ord a => Containers.Indexable (Containers.PrismMap.PrismMap k a) a k
instance Containers.Indexable (Containers.Pair.Pair a) Containers.Index a
instance Containers.Indexable (Containers.Quadruple.Quadruple a) Containers.Index a
instance Containers.Keyable [a] Containers.Index
instance GHC.Classes.Ord k => Containers.Keyable (Data.Map.Internal.Map k a) k
instance Containers.Keyable (Containers.PrismMap.PrismMap k a) k
instance Containers.Keyable (Containers.Pair.Pair a) Containers.Index
instance Containers.Keyable (Containers.Quadruple.Quadruple a) Containers.Index
instance Containers.Valuable [a] a
instance GHC.Classes.Ord a => Containers.Valuable (Data.Set.Internal.Set a) a
instance Containers.Valuable (Data.Map.Internal.Map k a) a
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Valuable (Containers.IsoMap.IsoMap a b) a
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Valuable (Containers.IsoMap.IsoMap a b) b
instance Containers.Valuable (Containers.PrismMap.PrismMap k a) a
instance Containers.Valuable (Containers.Pair.Pair a) a
instance Containers.Valuable (Containers.Quadruple.Quadruple a) a
instance Containers.Singletonable [a] a
instance Containers.Singletonable (Data.Set.Internal.Set a) a
instance Containers.Singletonable (Data.Map.Internal.Map k a) (k, a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => Containers.Singletonable (Containers.IsoMap.IsoMap a b) (a, b)
instance Containers.Singletonable (Containers.PrismMap.PrismMap k a) (k, a)
instance Containers.Nullable [a]
instance Containers.Nullable (Data.Set.Internal.Set a)
instance Containers.Nullable (Data.Map.Internal.Map k a)
instance Containers.Nullable (Containers.IsoMap.IsoMap a b)
instance Containers.Nullable (Containers.PrismMap.PrismMap k a)
instance Containers.Sizable [a]
instance Containers.Sizable (Data.Set.Internal.Set a)
instance Containers.Sizable (Data.Map.Internal.Map k a)
instance Containers.Sizable (Containers.IsoMap.IsoMap a b)
instance Containers.Sizable (Containers.PrismMap.PrismMap k a)
instance Containers.Sizable (Containers.Pair.Pair a)
instance Containers.Sizable (Containers.Quadruple.Quadruple a)

module GroupPresentation.Relation
type Relation = Pair EWord
relation :: EWord -> EWord -> Relation
relator :: EWord -> Relation
type Relations = Set Relation


-- | Module <a>GroupPresentation</a> include type of group presentation and
--   useful objects for working with it. This module also export other
--   useful modules.
module GroupPresentation
type GeneratorsDescr = IsoMap Generator String
data GroupPresentation
groupPresentation :: Relations -> GeneratorsDescr -> GroupPresentation
relations :: Lens' GroupPresentation Relations
generatorsDescr :: Lens' GroupPresentation GeneratorsDescr
type GPGetter a = Getter GroupPresentation a
generators :: GPGetter (Set Generator)
allGenerators :: GPGetter (Set Generator)
strGenerators :: GPGetter (Set String)
instance GHC.Show.Show GroupPresentation.GroupPresentation

module GP2GAP
gapFormat :: MonadFail m => GroupPresentation -> m GAPformat

module ParsingHelpers
type Parser = Parsec Void Text
makeEofParser :: Parser a -> Parser a
parseFromFile :: Parser a -> FilePath -> FilePath -> IO a


-- | This module represents functionality for reading grammar definitions
--   from given files and determing their type.
--   
--   Depending on the type of grammar, specific algorithm for building a
--   group will be executed.
module GrammarReader
parser :: Parser Grammar
parseFromFile :: Parser a -> FilePath -> FilePath -> IO a

-- | Method for classifying type of input grammar.
checkGrammarType :: Grammar -> GrammarType
instance GHC.Show.Show GrammarReader.ParserToken
instance GHC.Classes.Ord GrammarReader.ParserToken
instance GHC.Classes.Eq GrammarReader.ParserToken

module SemigroupPresentation.Generator
data Generator
generator :: Int -> Generator
numGenerator :: Generator -> Int
type GWord = [Generator]
type StrGWord = [String]
filterByFormat :: String -> Getter (Set String) (Set String)
matchWithFormat :: String -> Getter (Set String) (Set String)
insertGen :: String -> Getter (Set String) (Set String)
instance GHC.Enum.Enum SemigroupPresentation.Generator.Generator
instance GHC.Classes.Ord SemigroupPresentation.Generator.Generator
instance GHC.Classes.Eq SemigroupPresentation.Generator.Generator
instance GHC.Enum.Bounded SemigroupPresentation.Generator.Generator

module SemigroupPresentation.Relation
type Relation = Pair GWord
relation :: GWord -> GWord -> Relation
relator :: GWord -> Relation
type Relations = Set Relation
type StrRelation = Pair StrGWord
forAll :: Ord b => (a -> b) -> Getter (Set (Pair a)) (Set (Pair b))
replaceGenerator :: (String, String) -> StrGWord -> StrGWord


-- | Module <a>SemigroupPresentation</a> include type of semigroup
--   presentation and useful objects for working with it. This module also
--   export other useful modules.
module SemigroupPresentation
type GeneratorsDescr = IsoMap Generator String
data SemigroupPresentation
semigroupPresentation :: Relations -> GeneratorsDescr -> SemigroupPresentation
relations :: Lens' SemigroupPresentation Relations
generatorsDescr :: Lens' SemigroupPresentation GeneratorsDescr
type SPGetter a = Getter SemigroupPresentation a
type SPGetting a = Getting a SemigroupPresentation a
type SPTraversal' a = Traversal' SemigroupPresentation a
generators :: SPTraversal' Generator
allGenerators :: SPGetter (Set Generator)
strRelations :: SPGetting (Set StrRelation)
strGenerators :: SPGetting (Set String)
strNumRelations :: SPGetting (Set String)
asStrSet :: Show a => Getter a (Set String)
instance GHC.Show.Show SemigroupPresentation.SemigroupPresentation

module SP2GP.Relations
type Rels = [Rel]
(===) :: String -> String -> Rel
for' :: RangeClass v c => Range v c -> Rels -> Rel
in' :: RangeClass v c => v -> c -> Range v c
rels :: MonadFail m => Rels -> GeneratorsDescr -> SemigroupPresentation -> m Relations
instance GHC.Show.Show SP2GP.Relations.GenPow
instance SP2GP.Relations.RangeClass SP2GP.Relations.Rel (SP2GP.Relations.SetGetter SemigroupPresentation.Relation.StrRelation)
instance SP2GP.Relations.RangeClass GHC.Base.String (SP2GP.Relations.SetGetter GHC.Base.String)
instance (SP2GP.Relations.RangeClass v1 c1, SP2GP.Relations.RangeClass v2 c2) => SP2GP.Relations.RangeClass (v1, v2) (c1, c2)

module SP2GP.Generators
type Gens = [Gen]
simple :: String -> Gen
from :: String -> StrGetter -> Gen
group :: StrGetter -> Gen
gens :: MonadFail m => Gens -> SemigroupPresentation -> m GeneratorsDescr


-- | Module <tt>SP2GP</tt> include functions <a>groupBeta</a> and
--   <tt>groupBeta_1</tt> for converting semigroup presentation to group
--   presentation.
module SP2GP
groupBeta :: MonadFail m => SemigroupPresentation -> m GroupPresentation

module SemigroupPresentation.Solver
type Depth = Maybe Int
type Rule = (GWord, GWord)
solve :: MonadFail m => String -> SemigroupPresentation -> Depth -> String -> m [Rule]
instance GHC.Classes.Ord SemigroupPresentation.Solver.RuleType
instance GHC.Classes.Eq SemigroupPresentation.Solver.RuleType

module StringRewriting.Generator
data Generator
generator :: Int -> Generator
numGenerator :: Generator -> Int
type GWord = [Generator]
instance GHC.Classes.Ord StringRewriting.Generator.Generator
instance GHC.Classes.Eq StringRewriting.Generator.Generator

module StringRewriting.Rule
data Rule
rule :: GWord -> GWord -> Rule
left :: Lens' Rule GWord
right :: Lens' Rule GWord
toPair :: Rule -> (GWord, GWord)
type Rules = Set Rule
instance GHC.Classes.Ord StringRewriting.Rule.Rule
instance GHC.Classes.Eq StringRewriting.Rule.Rule


-- | Module <a>StringRewriting</a> include type of string rewriting system
--   and useful objects for working with it. This module also export other
--   useful modules.
module StringRewriting
type GeneratorsDescr = IsoMap Generator String
data StringRewriting
stringRewriting :: Rules -> GeneratorsDescr -> StringRewriting
rules :: Lens' StringRewriting Rules
generatorsDescr :: Lens' StringRewriting GeneratorsDescr
instance GHC.Show.Show StringRewriting.StringRewriting

module StringRewriting.Rewrite
rewrite :: MonadFail m => StringRewriting -> String -> m String
rewrite' :: StringRewriting -> GWord -> GWord

module StringRewriting.KnuthBendix
type Order a = a -> a -> Ordering
knuthBendix :: Set (Pair GWord) -> GeneratorsDescr -> StringRewriting
knuthBendixBy :: GenOrder -> Set (Pair GWord) -> GeneratorsDescr -> StringRewriting
instance GHC.Classes.Eq StringRewriting.KnuthBendix.GenWithOrder
instance GHC.Classes.Ord StringRewriting.KnuthBendix.GenWithOrder

module SP2SR
sp2sr :: MonadFail m => Order Generator -> SemigroupPresentation -> m StringRewriting
sp2sr' :: MonadFail m => SemigroupPresentation -> m StringRewriting

module GP2SR
gp2sr :: MonadFail m => Order Element -> GroupPresentation -> m StringRewriting
gp2sr' :: MonadFail m => GroupPresentation -> m StringRewriting


-- | This module represents a types of Turing machine.
module TMType

-- | This type represents a state of the Turing machine <a>TM</a>.
newtype State
State :: String -> State

-- | Type of a k-vector of tapes states, where k is a count of tapes.
--   
--   Type represents all states of the Turing machine <a>TM</a>.
newtype MultiTapeStates
MultiTapeStates :: [Set State] -> MultiTapeStates

-- | Type of a k-vector of a start states of the Turing machine <a>TM</a>.
newtype StartStates
StartStates :: [State] -> StartStates

-- | Type of a k-vector of a final states of the Turing machine <a>TM</a>.
newtype AccessStates
AccessStates :: [State] -> AccessStates

-- | Type of a state in a changed Turing machine, which has a form F_q,
--   where q is a <a>State</a>.
newtype StateOmega
StateOmega :: State -> StateOmega
[state] :: StateOmega -> State

-- | Type of a command of the Turing machine <a>TM</a>, which applicable on
--   a single tape.
--   
--   <a>SingleTapeCommand</a> is a command for normal Turing machine.
--   
--   <a>PreSMCommand</a> is a command for Turing machine after change.
data TapeCommand
SingleTapeCommand :: ((Square, State, Square), (Square, State, Square)) -> TapeCommand
PreSMCommand :: ((Square, StateOmega), (Square, StateOmega)) -> TapeCommand

-- | This is a data type of square of the Turing machine <a>TM</a>.
--   
--   <a>Value</a> is a square of string.
--   
--   <a>E</a> is a square, which we use after change of Turing machine, for
--   representing empties of a tape, and its argument marks the tape
--   number.
--   
--   <a>RBS</a> is a right bounding square.
--   
--   <a>LBS</a> is a left bounding square.
--   
--   <a>ES</a> is a empty square.
--   
--   <a>PCommand</a> is a square of command with parentheses surroundings.
--   
--   <a>BCommand</a> is a square of command with brackets surroundings.
data Square
Value :: String -> Int -> Square
[val_name] :: Square -> String
[val_quote_cnt] :: Square -> Int
E :: Int -> Square
RBS :: Square
LBS :: Square
ES :: Square
PCommand :: [TapeCommand] -> Square
BCommand :: [TapeCommand] -> Square

-- | Type of input alphabet of the Turing machine <a>TM</a>.
newtype InputAlphabet
InputAlphabet :: Set Square -> InputAlphabet

-- | Type of tape alphabet of the Turing machine <a>TM</a>.
newtype TapeAlphabet
TapeAlphabet :: Set Square -> TapeAlphabet

-- | Type of commands of a Turing machine <a>TM</a>.
newtype Commands
Commands :: Set [TapeCommand] -> Commands

-- | This type represents a Turing macine.
newtype TM
TM :: (InputAlphabet, [TapeAlphabet], MultiTapeStates, Commands, StartStates, AccessStates) -> TM
instance GHC.Show.Show TMType.State
instance GHC.Classes.Ord TMType.State
instance GHC.Classes.Eq TMType.State
instance GHC.Show.Show TMType.MultiTapeStates
instance GHC.Classes.Ord TMType.MultiTapeStates
instance GHC.Classes.Eq TMType.MultiTapeStates
instance GHC.Show.Show TMType.StartStates
instance GHC.Classes.Ord TMType.StartStates
instance GHC.Classes.Eq TMType.StartStates
instance GHC.Show.Show TMType.AccessStates
instance GHC.Classes.Ord TMType.AccessStates
instance GHC.Classes.Eq TMType.AccessStates
instance GHC.Classes.Ord TMType.StateOmega
instance GHC.Classes.Eq TMType.StateOmega
instance GHC.Show.Show TMType.TapeCommand
instance GHC.Classes.Ord TMType.TapeCommand
instance GHC.Classes.Eq TMType.TapeCommand
instance GHC.Show.Show TMType.Square
instance GHC.Classes.Ord TMType.Square
instance GHC.Classes.Eq TMType.Square
instance GHC.Show.Show TMType.InputAlphabet
instance GHC.Classes.Ord TMType.InputAlphabet
instance GHC.Classes.Eq TMType.InputAlphabet
instance GHC.Show.Show TMType.TapeAlphabet
instance GHC.Classes.Ord TMType.TapeAlphabet
instance GHC.Classes.Eq TMType.TapeAlphabet
instance GHC.Show.Show TMType.Commands
instance GHC.Classes.Ord TMType.Commands
instance GHC.Classes.Eq TMType.Commands
instance GHC.Show.Show TMType.TM
instance GHC.Classes.Ord TMType.TM
instance GHC.Classes.Eq TMType.TM
instance GHC.Show.Show TMType.StateOmega


-- | This module represents types of S-machine.
module SMType

-- | This is state name data type of <a>State</a>.
--   
--   Every constructor here represents name of the <a>State</a>.
data StateName
E :: StateName
X :: StateName
F :: StateName
P :: StateName
Q :: StateName
R :: StateName
S :: StateName
T :: StateName
U :: StateName

-- | This is tag data type of <a>State</a>.
--   
--   <a>Hat</a> it's like a house roof.
--   
--   <a>Quote</a> is a '.
--   
--   <a>Dash</a> is a overline.
data Tag
Hat :: Tag
Quote :: Tag
Dash :: Tag

-- | <a>SMTag</a> is a tag for S-machines and shows what kind is it.
--   
--   <a>T4</a> for S-machine number 4.
--   
--   <a>T9</a> for number 9.
--   
--   <a>TAlpha</a> for alpha S-machine.
--   
--   <a>TOmega</a> for omega S-machine.
data SMTag
T4 :: SMTag
T9 :: SMTag
TAlpha :: SMTag
TOmega :: SMTag

-- | This is data type of Turing machine commands and has uses in
--   <a>StateVal</a> in order to define for which command belongs to
--   <tt>StatevVal</tt>.
data TMCMD
Command :: [TapeCommand] -> TMCMD
CommandAlias :: String -> TMCMD

-- | <a>StateVal</a> represents belongnes of <a>State</a> to tape, Turing
--   machine commands and S-machine <a>SM</a>.
data StateVal
StateVal :: Int -> Maybe TMCMD -> Maybe SMTag -> StateVal
[tape] :: StateVal -> Int
[tmCommand] :: StateVal -> Maybe TMCMD
[smTag] :: StateVal -> Maybe SMTag

-- | This data type represents state of S-machine <a>SM</a>.
--   
--   <a>s_name</a> represents a name of <a>State</a>.
--   
--   <a>s_idx</a> represents a low index of <a>State</a>.
--   
--   <a>s_tags</a> represents a set of <a>Tag</a> of <a>State</a>.
--   
--   <a>s_val</a> represents a <a>StateVal</a> of <a>State</a>.
data State
State :: StateName -> String -> Set Tag -> Maybe StateVal -> State
[s_name] :: State -> StateName
[s_idx] :: State -> String
[s_tags] :: State -> Set Tag
[s_val] :: State -> Maybe StateVal

-- | This data type represents a tape letter of S-machine <a>SM</a>.
data Y
Y :: Square -> Y
Alpha :: Y
Delta :: Y
Omega :: Y

-- | This is a data type of symbols that can be on <a>SM</a> tape.
--   
--   Symbols can be <a>Y</a> (<a>SmbY</a>), its invertions (<a>SmbY'</a>)
--   and <a>State</a> (<a>SmbQ</a>).
data Smb
SmbY :: Y -> Smb
SmbY' :: Y -> Smb
SmbQ :: State -> Smb

-- | This is a admissible word of the S-machine <a>SM</a>, which consist of
--   the <a>Smb</a>.
newtype Word
Word :: [Smb] -> Word

-- | This is a rule of the S-machine <a>SM</a>.
--   
--   Left part of the pair represents what substitute.
--   
--   Right part -- for what substitute.
newtype SRule
SRule :: [(Word, Word)] -> SRule

-- | This is data type of S-machine.
--   
--   It consists of a lists of tape letters <a>Y</a>, states <a>State</a>
--   and rules <a>SRule</a>.
data SM
SM :: [[Y]] -> [Set State] -> [SRule] -> SM
[yn] :: SM -> [[Y]]
[qn] :: SM -> [Set State]
[srs] :: SM -> [SRule]
instance GHC.Classes.Ord SMType.StateName
instance GHC.Classes.Eq SMType.StateName
instance GHC.Show.Show SMType.Tag
instance GHC.Classes.Ord SMType.Tag
instance GHC.Classes.Eq SMType.Tag
instance GHC.Classes.Ord SMType.SMTag
instance GHC.Classes.Eq SMType.SMTag
instance GHC.Classes.Ord SMType.TMCMD
instance GHC.Classes.Eq SMType.TMCMD
instance GHC.Show.Show SMType.TMCMD
instance GHC.Classes.Ord SMType.StateVal
instance GHC.Classes.Eq SMType.StateVal
instance GHC.Show.Show SMType.StateVal
instance GHC.Classes.Eq SMType.State
instance GHC.Classes.Ord SMType.State
instance GHC.Show.Show SMType.State
instance GHC.Classes.Ord SMType.Y
instance GHC.Classes.Eq SMType.Y
instance GHC.Show.Show SMType.Y
instance GHC.Classes.Ord SMType.Smb
instance GHC.Classes.Eq SMType.Smb
instance GHC.Classes.Ord SMType.Word
instance GHC.Classes.Eq SMType.Word
instance GHC.Show.Show SMType.Word
instance GHC.Classes.Ord SMType.SRule
instance GHC.Classes.Eq SMType.SRule
instance GHC.Classes.Ord SMType.SM
instance GHC.Classes.Eq SMType.SM
instance GHC.Show.Show SMType.SM
instance GHC.Show.Show SMType.SRule
instance GHC.Show.Show SMType.Smb
instance GHC.Show.Show SMType.SMTag
instance GHC.Show.Show SMType.StateName

module TM2SMHelpers
eTag :: Set Tag
standardV :: Int -> Maybe StateVal
eTagState :: StateName -> String -> State
genRange :: Show a => StateName -> [a] -> [State]
gen :: StateName -> [State]
addTag :: Tag -> State -> State
addTags :: [Tag] -> [State] -> [State]
getai :: [TapeCommand] -> (Square, Int)
addICmdSmTag :: TMCMD -> SMTag -> State -> State
quoteTag :: Set Tag
dashTag :: Set Tag
hatTag :: Set Tag
hatdashTag :: Set Tag
newState :: StateName -> String -> Set Tag -> Int -> Maybe TMCMD -> Maybe SMTag -> State
eX :: Int -> Smb
eX' :: Int -> Smb
eF :: String -> Int -> Smb
eF' :: String -> Int -> Smb
eE :: Int -> Smb
eE' :: Int -> Smb
eP :: Int -> Smb
eQ :: Int -> Smb
eR :: Int -> Smb
eS :: Int -> Smb
eT :: Int -> Smb
eU :: Int -> Smb
ePd :: Int -> Smb
eQd :: Int -> Smb
eRd :: Int -> Smb
eSd :: Int -> Smb
eTd :: Int -> Smb
eUd :: Int -> Smb
getJIdx :: [TapeCommand] -> Int -> (String, String)


-- | This module represents group presentation and its sub-types.
module GRType

-- | This is a data type of <a>GR</a> generators.
--   
--   <a>A_Y</a> is a generators witch obtain from alphabet letters <a>Y</a>
--   of S-machine.
--   
--   <a>A_K</a> is a generators witch forms the <a>hubRelation</a>.
--   
--   <a>A_R</a> is a generators witch obtain from rules <a>SRule</a> of
--   S-machine.
--   
--   <a>A_Q</a> is a generators witch obtain from states <a>State</a> of
--   S-machine.
data A
A_Y :: Y -> A
A_K :: Int -> A
A_R :: SRule -> A
A_Q :: State -> A

-- | This is a data type of symbols in <a>GrRelation</a>.
--   
--   Symbols can represent generators <a>A</a> and its invertions.
--   
--   <a>SmbA</a> represents generators.
--   
--   <a>SmbA'</a> represents invertions of generators.
data SmbR
SmbA :: A -> SmbR
SmbA' :: A -> SmbR

-- | This is a data type of <a>GR</a> relations.
--   
--   <a>Relation</a> represents relation beetwen right and left symbols
--   <a>SmbR</a>.
--   
--   For example, relation ab=ba will coded like
--   
--   <pre>
--   &gt;&gt;&gt; Relation ([a, b], [b, a])
--   </pre>
--   
--   where a, b are <a>SmbR</a>
--   
--   <a>Relator</a> is relation in witch one part is identity.
--   
--   For example, ab=1 is
--   
--   <pre>
--   &gt;&gt;&gt; Relator [a,b]
--   </pre>
data GrRelation
Relation :: ([SmbR], [SmbR]) -> GrRelation
Relator :: [SmbR] -> GrRelation

-- | <a>GR</a> is a group presentation type.
--   
--   It consists of set of generators <a>A</a> and set of relations
--   <a>GrRelation</a>.
newtype GR
GR :: (Set A, Set GrRelation) -> GR
instance GHC.Classes.Ord GRType.A
instance GHC.Classes.Eq GRType.A
instance GHC.Show.Show GRType.A
instance GHC.Classes.Ord GRType.SmbR
instance GHC.Classes.Eq GRType.SmbR
instance GHC.Show.Show GRType.SmbR
instance GHC.Classes.Ord GRType.GrRelation
instance GHC.Classes.Eq GRType.GrRelation
instance GHC.Show.Show GRType.GrRelation
instance GHC.Classes.Ord GRType.GR
instance GHC.Classes.Eq GRType.GR
instance GHC.Show.Show GRType.GR

module Helpers
disjoinQuotes :: Int -> Square -> Square
getDisjoinSquare2 :: Square -> Square
getDisjoinSquare :: Square -> Square
disjoinIfTerminal :: Symbol -> Square
mapValue :: [String] -> [Square]
printSmb :: Map A String -> SmbR -> String
revertSmb :: SmbR -> SmbR
revertRel :: GrRelation -> [SmbR]
genNextStateList :: [State] -> State
genNextState :: Set State -> State
mapTuple :: (a -> b) -> (a, a) -> (b, b)
defValue :: String -> Square

module TM2SymTM
firstPhase :: [State] -> [TapeCommand] -> [[TapeCommand]] -> [State] -> [Set State] -> [State] -> [[TapeCommand]]
generateEmptyStayCommands :: [State] -> [TapeCommand] -> [TapeCommand]
secondPhase :: State -> [[TapeCommand]] -> [State] -> [[TapeCommand]]
thirdPhase :: State -> [[TapeCommand]] -> [State] -> [[TapeCommand]]
symCommands :: [[TapeCommand]] -> [[TapeCommand]]
threePhaseProcessing :: TM -> TM
doubleCommands :: [State] -> [State] -> [TapeAlphabet] -> [Set State] -> [[TapeCommand]] -> ([State], [State], [TapeAlphabet], [Set State], [[TapeCommand]])
one2KCmds :: ([Set State], [[TapeCommand]]) -> ([Set State], [[TapeCommand]])
cmd2SIDCmd :: ([Set State], [[TapeCommand]]) -> ([Set State], [[TapeCommand]])
symTM :: TM -> TM
symDetTM :: TM -> TM

module TM2SM
splitPosNegCmds :: [[TapeCommand]] -> ([[TapeCommand]], [[TapeCommand]], [[TapeCommand]], [[TapeCommand]])
copySMForCommand :: SM -> SMTag -> TMCMD -> SM
createSMs :: [Y] -> [SM]
genConnectingRules :: TMCMD -> [SRule]
genPos22Rule :: TMCMD -> SRule
symSM :: SRule -> SRule
sigmaFunc :: [State] -> [[Smb]] -> Word
renameRightLeftBoundings :: [[TapeCommand]] -> [[TapeCommand]]
tm2sm :: TM -> (SM, Word, [State])

module SMInterpreter
checkRule :: Word -> SRule -> Bool
getApplicableRules :: [SRule] -> [Word] -> [[SRule]]
reduceY :: [Smb] -> [Smb]
replaceSublist :: [Smb] -> (Word, Word) -> [Smb]
applyRule :: Word -> SRule -> Word
applyRules :: [Word] -> [SRule] -> Map Word Int -> [[Word]] -> ([[Word]], Map Word Int)
applyRuless :: [[Word]] -> [[SRule]] -> Map Word Int -> [[Word]] -> ([[Word]], Map Word Int)
getFront :: [[Word]] -> [Word]
startInterpreting :: Word -> [[Word]] -> [SRule] -> Map Word Int -> ([Word], Map Word Int)
interpretSM :: Word -> SM -> Word -> [Word]
getRestrictedGraph :: Word -> SM -> Int -> (Gr Word Int, Map Word Int)

module SM2GR
smb2As :: Smb -> SmbR
transitionRelations :: [SRule] -> [[State]] -> [GrRelation]
nk :: Int
k :: [A]
hubRelation :: Word -> [SmbR]
easyHubRelation :: Word -> [SmbR]
auxiliaryRelations :: [A] -> [A] -> [A] -> [GrRelation]
sm2grInternal :: (SM, Word) -> [A] -> GR
sm2gr :: (SM, Word) -> GR
sm2grEmpty :: (SM, Word) -> GR

module MapleFuncWriter
writeGenerators :: [A] -> Map A String -> Handle -> IO ()
writeRelations :: [GrRelation] -> Map A String -> Handle -> IO ()
writeMaple :: GR -> Handle -> Map A String -> IO ()

module GapFuncWriter
writeGenerators :: [A] -> Map A String -> Handle -> IO ()
writeRelations :: [GrRelation] -> Map A String -> Handle -> IO ()
writeGap :: GR -> Handle -> Map A String -> [SmbR] -> IO ()
writeWord :: [SmbR] -> Handle -> Map A String -> IO ()


-- | This module represents a configuration of the Turing machine
--   <a>TM</a>.
module ConfigType

-- | This is type of configurations of the Turing machine.
newtype Configs
Configs :: [[([Square], State, [Square])]] -> Configs
instance GHC.Show.Show ConfigType.Configs
instance GHC.Classes.Ord ConfigType.Configs
instance GHC.Classes.Eq ConfigType.Configs

module TMInterpreter
checkCommandTapeToTape :: [([Square], State, [Square])] -> [TapeCommand] -> Bool
applyCommand :: [([Square], State, [Square])] -> [TapeCommand] -> [[([Square], State, [Square])]] -> [([Square], State, [Square])] -> [[([Square], State, [Square])]]
applyCommands :: [[([Square], State, [Square])]] -> [[TapeCommand]] -> [[[([Square], State, [Square])]]]
applyCommandss :: [[[([Square], State, [Square])]]] -> [[[TapeCommand]]] -> [[[([Square], State, [Square])]]] -> [[[([Square], State, [Square])]]]
checkFinalEmptyStates :: [State] -> [([Square], State, [Square])] -> Bool
startInterpreting :: [State] -> [[[([Square], State, [Square])]]] -> [[TapeCommand]] -> [[([Square], State, [Square])]]
interpretTM :: [String] -> TM -> Configs

module CFG2TM
sSFT :: State
sSST :: State
fSFT :: State
fSST :: State
iSST :: State
first :: [Relation] -> Symbol -> [String]
follow :: [Relation] -> Symbol -> [String]
first2 :: [Symbol] -> [Relation] -> [String] -> [String]
genRelationCommand :: (Relation, State) -> [State] -> [Relation] -> ([State], [[TapeCommand]])
genEraseCommand :: Terminal -> [TapeCommand]
genPreviewCommand :: [Relation] -> [State] -> ([State], [[TapeCommand]], [(Relation, State)])
cfg2tm :: Grammar -> TM


-- | Module <tt>Time</tt> include useful functions for working calculations
--   which must be done after a certain period of time.
module Time
data TimeAccuracy
MS :: TimeAccuracy
S :: TimeAccuracy
M :: TimeAccuracy
H :: TimeAccuracy
class Monad m => MonadTimeout m
timeout :: (MonadTimeout m, RealFrac i, NFData a) => i -> TimeAccuracy -> m a -> m a
timeout' :: RealFrac i => i -> TimeAccuracy -> IO a -> IO (Maybe a)
instance Time.MonadTimeout GHC.Types.IO
instance Time.MonadTimeout GHC.Maybe.Maybe
instance Time.MonadTimeout m => Time.MonadTimeout (Control.Monad.Trans.Reader.ReaderT r m)
instance Time.MonadTimeout m => Time.MonadTimeout (Control.Monad.Trans.State.Lazy.StateT s m)


-- | This module provides types for representing turing machines in a
--   format suitable for the service:
--   <a>https://turingmachinesimulator.com/</a> Below this format will be
--   called Tms.
module TmsType

-- | Type of Tms tape square action.
--   
--   <a>Leave</a> is leave any character unchanged.
--   
--   'ChangeFromTo f t' is change it from <tt>f</tt> to <tt>t</tt>.
data TmsTapeSquare
Leave :: TmsTapeSquare
ChangeFromTo :: Char -> Char -> TmsTapeSquare

-- | Type of Tms tape head movement
data TmsTapeHeadMovement
MoveLeft :: TmsTapeHeadMovement
Stay :: TmsTapeHeadMovement
MoveRight :: TmsTapeHeadMovement

-- | Type of Tms State.
newtype TmsState
TmsState :: String -> TmsState

-- | Type of Tms command for one tape. TmsSingleTapeCommand (action,
--   movement).
newtype TmsSingleTapeCommand
TmsSingleTapeCommand :: (TmsTapeSquare, TmsTapeHeadMovement) -> TmsSingleTapeCommand

-- | Type of Tms single tape command
type OneTapeTMCommand = (TmsState, TmsSingleTapeCommand, TmsState)
toTmsCommand :: OneTapeTMCommand -> TmsCommand

-- | Type of Tms command for entire Turing machine.
newtype TmsCommand
TmsCommand :: (TmsState, [TmsSingleTapeCommand], TmsState) -> TmsCommand

-- | Type of Tms format. Tms (name, init accept commands, tapeAlphabets).
newtype Tms
Tms :: (String, TmsState, [TmsState], [TmsCommand], [String]) -> Tms

-- | Process string so that it does not contain illegal characters.
filterStateName :: String -> String
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
instance GHC.Classes.Ord TmsType.TmsTapeSquare
instance GHC.Classes.Eq TmsType.TmsTapeSquare
instance GHC.Classes.Ord TmsType.TmsTapeHeadMovement
instance GHC.Classes.Eq TmsType.TmsTapeHeadMovement
instance GHC.Classes.Ord TmsType.TmsState
instance GHC.Classes.Eq TmsType.TmsState
instance GHC.Classes.Ord TmsType.TmsSingleTapeCommand
instance GHC.Classes.Eq TmsType.TmsSingleTapeCommand
instance GHC.Classes.Ord TmsType.TmsCommand
instance GHC.Classes.Eq TmsType.TmsCommand
instance GHC.Classes.Eq TmsType.Tms
instance GHC.Show.Show TmsType.Tms
instance GHC.Show.Show TmsType.TmsTapeHeadMovement


-- | This module provides types for parsing <a>Tms</a> Turing machines.
module TmsParser
parser :: Parser Tms

-- | Parse Tms from file.
parseTms :: FilePath -> FilePath -> IO Tms

-- | Tms. Example:
--   
--   name: TuringMachine_1 init: q1 accept: q2, q3
--   
--   q1, _, x q2, a, y, -, &gt;
--   
--   q0, _, _ q3, a, _, &lt;, - Note: lines should not end with ' ', also
--   there could not be any newlines after Tms.
pTms :: Parser Tms


-- | This module provides functionality for converting the Turing machine
--   <a>TM</a> to <a>Tms</a>.
module TM2Tms
tm2tms :: TM -> Either String Tms

module TuringMachine.Move
data Move
toLeft :: Move
toRight :: Move
versa :: Move -> Move
instance GHC.Classes.Ord TuringMachine.Move.Move
instance GHC.Classes.Eq TuringMachine.Move.Move
instance GHC.Show.Show TuringMachine.Move.Move


-- | Module <a>Level</a> include levels of optimization of Turing machine.
module TuringMachine.Optimization.Level
data Level
O0 :: Level
O1 :: Level
O2 :: Level
maxO :: Level
levelGradation :: [a -> a] -> Level -> a -> a
instance GHC.Enum.Bounded TuringMachine.Optimization.Level.Level
instance GHC.Enum.Enum TuringMachine.Optimization.Level.Level
instance GHC.Classes.Ord TuringMachine.Optimization.Level.Level
instance GHC.Classes.Eq TuringMachine.Optimization.Level.Level

module TuringMachine.ShowedSymbol
data ShowedSymbol
blank :: ShowedSymbol
isBlank :: ShowedSymbol -> Bool
type ShowedSymbols = [ShowedSymbol]
class ShowedSymbolClass s
showedSymbols :: ShowedSymbolClass s => [s] -> ShowedSymbols
instance GHC.Classes.Ord TuringMachine.ShowedSymbol.ShowedSymbol
instance GHC.Classes.Eq TuringMachine.ShowedSymbol.ShowedSymbol
instance TuringMachine.ShowedSymbol.ShowedSymbolClass GHC.Types.Char
instance TuringMachine.ShowedSymbol.ShowedSymbolClass TuringMachine.ShowedSymbol.ShowedSymbol
instance GHC.Show.Show TuringMachine.ShowedSymbol.ShowedSymbol
instance GHC.Read.Read TuringMachine.ShowedSymbol.ShowedSymbol
instance Data.String.IsString TuringMachine.ShowedSymbol.ShowedSymbol

module TuringMachine.State
data State
state :: Int -> State
numState :: State -> Int
startState :: State
finalState :: State
instance GHC.Enum.Enum TuringMachine.State.State
instance GHC.Num.Num TuringMachine.State.State
instance GHC.Classes.Ord TuringMachine.State.State
instance GHC.Classes.Eq TuringMachine.State.State
instance GHC.Enum.Bounded TuringMachine.State.State

module TuringMachine.Symbol
data Symbol
symbol :: Int -> Symbol
numSymbol :: Symbol -> Int
blankSymbol :: Symbol
instance GHC.Enum.Enum TuringMachine.Symbol.Symbol
instance GHC.Num.Num TuringMachine.Symbol.Symbol
instance GHC.Classes.Ord TuringMachine.Symbol.Symbol
instance GHC.Classes.Eq TuringMachine.Symbol.Symbol
instance GHC.Enum.Bounded TuringMachine.Symbol.Symbol

module TuringMachine.SymbolOrMove
data MoveOr s
S :: s -> MoveOr s
M :: Move -> MoveOr s
type SymbolOrMove = MoveOr Symbol
type ShowedSymbolOrMove = MoveOr ShowedSymbol
getSymbol :: MonadFail m => MoveOr s -> m s
isSymbol :: MoveOr s -> Bool
getMove :: MonadFail m => MoveOr s -> m Move
isMove :: MoveOr s -> Bool
instance GHC.Classes.Ord s => GHC.Classes.Ord (TuringMachine.SymbolOrMove.MoveOr s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (TuringMachine.SymbolOrMove.MoveOr s)

module TuringMachine.Quadruple
type QuadrupleFromPart = (State, Symbol)
type QuadrupleToPart = (SymbolOrMove, State)
type Quadruple = (QuadrupleFromPart, QuadrupleToPart)
type Quadruples = Map QuadrupleFromPart QuadrupleToPart
type StrQuadruple = Quadruple String
type StrPair = Pair String
toStrQ :: Quadruple -> StrQuadruple
type Predicate a = a -> Bool
(&.) :: Predicate a -> Predicate a -> Predicate a
infixr 3 &.
(|.) :: Predicate a -> Predicate a -> Predicate a
infixr 2 |.
fromState :: State -> StrQuadruplePredicate
toState :: State -> StrQuadruplePredicate
fromSymbol :: Symbol -> StrQuadruplePredicate
toSymbol :: Symbol -> StrQuadruplePredicate
withMove :: Move -> StrQuadruplePredicate
withoutMove :: StrQuadruplePredicate
takeOnly :: Predicate a -> Getter (Set a) (Set a)
takeFromPart :: Getter (Set StrQuadruple) (Set StrPair)
takeToPart :: Getter (Set StrQuadruple) (Set StrPair)
withoutLoops :: Getter (Set StrQuadruple) (Set StrQuadruple)
copy :: (Listable c String, Indexable c Index String) => Int -> Getter (Set c) (Set [String])


-- | Module <a>TuringMachine</a> include type of Turing machine and useful
--   objects for working with it. This module also export other useful
--   modules.
module TuringMachine
type LabeledStates = PrismMap String State
type Alphabet = IsoMap ShowedSymbol Symbol
data TuringMachine
turingMachine :: Quadruples -> LabeledStates -> Alphabet -> TuringMachine
quadruples :: Lens' TuringMachine Quadruples
labeledStates :: Lens' TuringMachine LabeledStates
alphabet :: Lens' TuringMachine Alphabet
type TMGetter a = Getter TuringMachine a
type TMSetter a b = Setter TuringMachine TuringMachine a b
states :: TMSetter State (Maybe State)
symbols :: TMSetter Symbol (Maybe Symbol)
allStates :: TMGetter (Set State)
allSymbols :: TMGetter (Set Symbol)
strQuadruples :: TMGetter (Set StrQuadruple)
strLabeledStates :: TMGetter (Set String)
strSymbols :: TMGetter (Set String)
strNumStates :: TMGetter (Set String)
strNumSymbols :: TMGetter (Set String)
maxNumState :: TMGetter Int
maxNumSymbol :: TMGetter Int

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a

-- | A set of values <tt>a</tt>.
data Set a
newtype Pair a
Pair :: (a, a) -> Pair a
[unPair] :: Pair a -> (a, a)
unQuadruple :: Quadruple a -> (a, a, a, a)
data IsoMap a b
data PrismMap k a
class Deletable c v
delete :: (Deletable c v, MonadFail m) => v -> c -> m c
delete :: (Deletable c v, Containable c v, MonadFail m) => v -> c -> m c
unsafeDelete :: Deletable c v => v -> c -> c
(\>) :: Deletable c v => v -> c -> c
(<\) :: Deletable c v => c -> v -> c
(<\~) :: Deletable c v => ASetter s t c c -> v -> s -> t
(<\=) :: (Deletable c v, MonadState s m) => ASetter s s c c -> v -> m ()
infix 4 <\=
infixr 4 <\~
infixl 6 <\
infixr 7 \>
class Insertable c v
insert :: (Insertable c v, MonadFail m) => v -> c -> m c
insert :: (Insertable c v, Containable c v, MonadFail m) => v -> c -> m c
unsafeInsert :: Insertable c v => v -> c -> c
(+>) :: Insertable c v => v -> c -> c
(<+) :: Insertable c v => c -> v -> c
(<+~) :: Insertable c v => ASetter s t c c -> v -> s -> t
(<+=) :: (Insertable c v, MonadState s m) => ASetter s s c c -> v -> m ()
infixl 6 <+
infixr 7 +>
infix 4 <+=
infixr 4 <+~
class Filterable c v
filterC :: Filterable c v => (v -> Bool) -> c -> c
(<?>) :: Filterable c v => (v -> Bool) -> c -> c
(<?>~) :: Filterable c v => ASetter s t c c -> (v -> Bool) -> s -> t
(<?>=) :: (Filterable c v, MonadState s m) => ASetter s s c c -> (v -> Bool) -> m ()
infix 4 <?>=
infixr 4 <?>~
infix 4 <?>
class Gunctor c1 c2 v1 v2 | c1 c2 -> v1 v2
gmap :: Gunctor c1 c2 v1 v2 => (v1 -> v2) -> c1 -> c2
(<@>) :: Gunctor c1 c2 v1 v2 => (v1 -> v2) -> c1 -> c2
infix 4 <@>
class Containable c v
member :: Containable c v => v -> c -> Bool
notMember :: Containable c v => v -> c -> Bool
class FastUnsafeListable c v | c -> v
fromAscList :: FastUnsafeListable c v => [v] -> c
fromDistinctAscList :: FastUnsafeListable c v => [v] -> c
fromDescList :: FastUnsafeListable c v => [v] -> c
fromDistinctDescList :: FastUnsafeListable c v => [v] -> c
class UnsafeListable c v | c -> v
fromList :: UnsafeListable c v => [v] -> c
class Listable c v | c -> v
toList :: Listable c v => c -> [v]
toList :: (Listable c v, Valuable c v) => c -> [v]
fromList_ :: (Listable c v, MonadFail m) => [v] -> m c
fromList_ :: (Listable c v, UnsafeListable c v, MonadFail m) => [v] -> m c
class Operable c
union :: Operable c => c -> c -> c
(\/) :: Operable c => c -> c -> c
(\/~) :: Operable c => ASetter s t c c -> c -> s -> t
(\/=) :: (Operable c, MonadState s m) => ASetter s s c c -> c -> m ()
intersection :: Operable c => c -> c -> c
(/\) :: Operable c => c -> c -> c
(/\~) :: Operable c => ASetter s t c c -> c -> s -> t
(/\=) :: (Operable c, MonadState s m) => ASetter s s c c -> c -> m ()
difference :: Operable c => c -> c -> c
(\\) :: Operable c => c -> c -> c
(\\~) :: Operable c => ASetter s t c c -> c -> s -> t
(\\=) :: (Operable c, MonadState s m) => ASetter s s c c -> c -> m ()
infix 4 \\=
infix 4 /\=
infix 4 \/=
infixr 4 \\~
infixr 4 /\~
infixr 4 \/~
infixl 5 /\
infixl 5 \/
infixl 5 \\
class Slicable c k
takeC :: Slicable c k => k -> c -> c
dropC :: Slicable c k => k -> c -> c
splitAtC :: Slicable c k => k -> c -> (c, c)
class Indexable c k v | c k -> v, c v -> k
(!?) :: (Indexable c k v, MonadFail m) => c -> k -> m v
(!<>) :: Indexable c k v => c -> k -> Set v
(.@) :: (Indexable c k v, MonadFail m) => Getting x y c -> k -> Getting x y (m v)
(.<@>) :: Indexable c k v => Getting x y c -> k -> Getting x y (Set v)
infixr 9 .<@>
infixr 9 .@
infixl 9 !?
infixl 9 !<>
class Keyable c k | c -> k
keys :: Keyable c k => c -> [k]
keys :: (Keyable c k, Ord k) => c -> [k]
keysSet :: (Keyable c k, Ord k) => c -> Set k
class Valuable c v
values :: Valuable c v => c -> [v]
values :: (Valuable c v, Ord v) => c -> [v]
valuesSet :: (Valuable c v, Ord v) => c -> Set v
class Singletonable c v | c -> v
singleton :: Singletonable c v => v -> c
class Nullable c
nullC :: Nullable c => c -> Bool
nullC :: (Nullable c, Sizable c) => c -> Bool
emptyC :: Nullable c => c
class Sizable c
size :: Sizable c => c -> Int
data Index
index :: Int -> Index
instance GHC.Show.Show TuringMachine.TuringMachine
instance GHC.Classes.Eq TuringMachine.TuringMachine


-- | Module <a>Safe</a> include function <a>secure</a> for increasing of
--   security of Turing machine.
module TuringMachine.Optimization.Safe
secure :: TuringMachine -> TuringMachine


-- | Module <a>Constructors</a> include a lot of constructors of Turing
--   machine.
module TuringMachine.Constructors
makeStandartTM :: [LocalQuadruple] -> TuringMachine
crash :: TuringMachine
check :: ShowedSymbolClass s => [s] -> TuringMachine
die :: ShowedSymbolClass s => [s] -> TuringMachine
move :: ShowedSymbolClass s => Move -> [s] -> TuringMachine
moveInf :: ShowedSymbolClass s => Move -> [s] -> TuringMachine
rewrite :: ShowedSymbolClass s => [s] -> ShowedSymbol -> TuringMachine
rewriteAndMove :: ShowedSymbolClass s => [s] -> ShowedSymbol -> Move -> TuringMachine
(+^>) :: String -> TuringMachine -> TuringMachine
infixl 8 +^>
(>+^) :: TuringMachine -> String -> TuringMachine
infixl 8 >+^
(-^) :: TuringMachine -> String -> TuringMachine
(++>) :: TuringMachine -> TuringMachine -> TuringMachine
infixl 6 ++>
(||>) :: TuringMachine -> TuringMachine -> TuringMachine
infixl 5 ||>
(@@>) :: TuringMachine -> TuringMachine -> TuringMachine
infix 7 @@>
loop :: TuringMachine -> TuringMachine
forSs :: ShowedSymbolClass s => (ShowedSymbol -> TuringMachine) -> [s] -> TuringMachine


-- | Module <a>Optimization</a> include functions for reducing size of
--   Turing machine with saving of functionality.
module TuringMachine.Optimization
optimize :: Level -> TuringMachine -> TuringMachine
optimal :: Level -> TuringMachine -> Bool
ifCanOptimize :: MonadFail m => Level -> TuringMachine -> m TuringMachine
safeOptimize :: Level -> TuringMachine -> TuringMachine
safeOptimal :: Level -> TuringMachine -> Bool
ifCanSafeOptimize :: MonadFail m => Level -> TuringMachine -> m TuringMachine
data DiffTM
diffTM :: Level -> TuringMachine -> DiffTM
instance GHC.Show.Show TuringMachine.Optimization.DiffTM


-- | This module provides functionality for converting the Turing machine
--   <a>Tms</a> to <a>TM</a>.
module Tms2TuringMachine
tms2turingMachine :: Tms -> Either String TuringMachine

-- | Hash function used to proivde algorithm with extra unique names.
hash :: String -> Int

module TM2SP.Relations
type Rels = [Rel]
(===) :: String -> String -> Rel
for' :: RangeElement e => Range e -> Rels -> Rel
in' :: RangeElement e => String -> SetGetter e -> Range e
rels :: MonadFail m => Rels -> GeneratorsDescr -> TuringMachine -> m Relations
instance TM2SP.Relations.RangeElement GHC.Base.String
instance TM2SP.Relations.RangeElement (Containers.Quadruple.Quadruple GHC.Base.String)
instance TM2SP.Relations.RangeElement [GHC.Base.String]

module TM2SP.Generators
type Gens = [Gen]
simple :: String -> Gen
from :: String -> StrGetter -> Gen
gens :: MonadFail m => Gens -> TuringMachine -> m GeneratorsDescr


-- | Module <a>ShowInfo</a> include class <a>ShowInfo</a> for pretty
--   printing of objects in this project.
module ShowInfo
newtype Title
Title :: String -> Title
data WithTitle a
withTitle :: Title -> a -> WithTitle a
title :: WithTitle a -> Title
withoutTitle :: WithTitle a -> a
class ShowInfo a
showTitle :: ShowInfo a => a -> Title
showInfo :: ShowInfo a => a -> String
showTitleAndInfo :: ShowInfo a => a -> String
showListTitle :: ShowInfo a => [a] -> Title
showListInfo :: ShowInfo a => [a] -> String
instance GHC.Classes.Ord ShowInfo.Title
instance GHC.Classes.Eq ShowInfo.Title
instance ShowInfo.ShowInfo GHC.Types.Char
instance ShowInfo.ShowInfo GrammarType.Grammar
instance ShowInfo.ShowInfo TuringMachine.TuringMachine
instance ShowInfo.ShowInfo TMType.TM
instance ShowInfo.ShowInfo SemigroupPresentation.SemigroupPresentation
instance ShowInfo.ShowInfo GroupPresentation.GroupPresentation
instance ShowInfo.ShowInfo GRType.GR
instance ShowInfo.ShowInfo a => ShowInfo.ShowInfo (ShowInfo.WithTitle a)
instance ShowInfo.ShowInfo a => ShowInfo.ShowInfo [a]
instance (ShowInfo.ShowInfo a, ShowInfo.ShowInfo b) => ShowInfo.ShowInfo (a, b)
instance (ShowInfo.ShowInfo a, ShowInfo.ShowInfo b, ShowInfo.ShowInfo c) => ShowInfo.ShowInfo (a, b, c)
instance (ShowInfo.ShowInfo a, ShowInfo.ShowInfo b, ShowInfo.ShowInfo c, ShowInfo.ShowInfo d) => ShowInfo.ShowInfo (a, b, c, d)
instance GHC.Show.Show ShowInfo.Title
instance Data.String.IsString ShowInfo.Title
instance Containers.Insertable ShowInfo.Title GHC.Types.Char


-- | Module <tt>TM2SP</tt> include functions <a>semigroupGamma</a>,
--   <a>semigroupGamma_1</a> and <a>semigroupGamma_2</a> for converting
--   Turing machine to semigroup presentation.
module TM2SP
convertInput :: MonadFail m => TuringMachine -> (String, Int) -> m String
semigroupGamma :: MonadFail m => TuringMachine -> m SemigroupPresentation
semigroupGamma_1 :: MonadFail m => TuringMachine -> m SemigroupPresentation
semigroupGamma_2 :: MonadFail m => TuringMachine -> m SemigroupPresentation

module DebuggingTMTypes
newtype DebuggingState
DState :: String -> DebuggingState
newtype DebuggingSymbol
DSymbol :: String -> DebuggingSymbol
[unDSymbol] :: DebuggingSymbol -> String
data DebuggingMove
D :: DebuggingSymbol -> DebuggingMove
L :: DebuggingMove
R :: DebuggingMove
newtype DebuggingQuadruples
DQuadruples :: Map (DebuggingState, DebuggingSymbol) (DebuggingMove, DebuggingState) -> DebuggingQuadruples
newtype DebuggingTuringMachine
DTM :: DebuggingQuadruples -> DebuggingTuringMachine
finalDState :: DebuggingState
startDState :: DebuggingState
newtype SymbolsPair
SymbolsPair :: (Nonterminal, Int, Bool, Symbol, Symbol) -> SymbolsPair
convertToTuringMachine :: MonadFail m => DebuggingTuringMachine -> m TuringMachine
getStates :: DebuggingTuringMachine -> IsoMap DebuggingState State
getSymbols :: DebuggingTuringMachine -> (Alphabet, IsoMap DebuggingSymbol Symbol)
instance GHC.Show.Show DebuggingTMTypes.DebuggingState
instance GHC.Classes.Ord DebuggingTMTypes.DebuggingState
instance GHC.Classes.Eq DebuggingTMTypes.DebuggingState
instance GHC.Show.Show DebuggingTMTypes.DebuggingSymbol
instance GHC.Classes.Ord DebuggingTMTypes.DebuggingSymbol
instance GHC.Classes.Eq DebuggingTMTypes.DebuggingSymbol
instance GHC.Show.Show DebuggingTMTypes.DebuggingMove
instance GHC.Classes.Ord DebuggingTMTypes.DebuggingMove
instance GHC.Classes.Eq DebuggingTMTypes.DebuggingMove
instance GHC.Show.Show DebuggingTMTypes.DebuggingQuadruples
instance GHC.Classes.Ord DebuggingTMTypes.DebuggingQuadruples
instance GHC.Classes.Eq DebuggingTMTypes.DebuggingQuadruples
instance GHC.Classes.Eq DebuggingTMTypes.DebuggingTuringMachine
instance GHC.Show.Show DebuggingTMTypes.DebuggingTuringMachine
instance GHC.Show.Show DebuggingTMTypes.SymbolsPair
instance GHC.Classes.Eq DebuggingTMTypes.SymbolsPair

module Boolean2TMHelpers
calculateMaxNumberOfRulesForNonterminal :: Grammar -> Int
calculateGroupRelationsByNonterminals :: [Relation] -> Map Nonterminal [[Conj]]
calculateNextConjunctionInSameRule :: Grammar -> SymbolsPair -> Maybe SymbolsPair
calculateFirstConjunctionInNextRule :: Grammar -> SymbolsPair -> Maybe SymbolsPair
getFstConjInKthRel :: Grammar -> String -> String -> SymbolsPair
getLongRels :: [Relation] -> [Relation]
getShortRightParts :: Nonterminal -> [[Conj]] -> [String]
getNumbersOfShortRelations :: Grammar -> Map Nonterminal [String]
getFstNonterminalsInConjsOfGivenRel :: Grammar -> String -> String -> [String]
getSndNonterminalsInConjsOfGivenRel :: Grammar -> String -> String -> String -> [String]
calculateTriplets :: Grammar -> String -> [String] -> [(String, String, String)]
calculateQuads' :: Grammar -> [([Char], [Char], [Char])] -> [(String, String, String, [String])]
calculateQuads :: Grammar -> String -> [String] -> [(String, String, String, String)]
calculateAllQuads :: Grammar -> [(String, String, String, String)]
checkIfConjHasNeg :: Grammar -> (String, String, String, String) -> Bool
kthRelForNonterminalLong :: [Relation] -> String -> String -> Bool
relationHasOneTerminalInRightPart :: Relation -> Bool
symbolAcceptedByNonterminal :: Grammar -> String -> String -> Bool
refineSymbolInConjunctionToNonterminal :: Symbol -> String
addCollectionToMap :: Ord k => [(k, a)] -> Map k a -> Map k a
refineSymbolToTerminalValue :: Symbol -> String
constructSymbolsPairByQuad :: (String, String, String, String) -> Bool -> SymbolsPair
convertListToConjunctionPair :: Nonterminal -> Int -> Conj -> SymbolsPair
getShiftsDecrements :: Int -> String -> [(String, String)]

module Boolean2TM
boolean2tm :: MonadFail m => Grammar -> m TuringMachine
boolean2tm' :: Grammar -> DebuggingTuringMachine


-- | Module <a>Tape</a> include type of Turing machine's tape and useful
--   functions for working with it.
module TuringMachine.Interpreter.Tape
data Tape
top :: Lens' Tape TapeSymbol
move :: Move -> Getter Tape Tape
fromString :: String -> Int -> Tape
instance GHC.Classes.Eq TuringMachine.Interpreter.Tape.Tape
instance GHC.Show.Show TuringMachine.Interpreter.Tape.Tape


-- | Module <a>Interpreter</a> include functions for interpreting of Turing
--   machine.
module TuringMachine.Interpreter
data WorkingState
currentState :: Lens' WorkingState State
tape :: Lens' WorkingState Tape
step :: MonadFail m => TuringMachine -> WorkingState -> m (Quadruple, WorkingState)
initWS :: String -> Int -> WorkingState
run :: TuringMachine -> WorkingState -> [WorkingState]
smartRun :: TuringMachine -> WorkingState -> [WorkingState]
superSmartRun :: MonadFail m => TuringMachine -> WorkingState -> m [WorkingState]
instance GHC.Classes.Eq TuringMachine.Interpreter.WorkingState
instance GHC.Show.Show TuringMachine.Interpreter.WorkingState


-- | Module <a>Admiter</a> include <a>admit</a> function for detecting if
--   input Turing machine admit input string.
module TuringMachine.Admiter
type Depth = Maybe Int
type Action = SymbolOrMove
admit :: MonadFail m => TuringMachine -> Depth -> (String, Int) -> m [Action]
admit' :: MonadFail m => TuringMachine -> Depth -> WorkingState -> m [Action]


-- | Module <a>TMs</a> include set of Turing machines for testing.
module TuringMachine.TMs
testingSetTMs :: [WithTitle TuringMachine]


-- | This module represents functionality for converting the
--   <a>TuringMachine</a> to <a>Tms</a>.
module TuringMachine2Tms
turingMachine2tms :: TuringMachine -> Tms
turingMachineSt2tmsSt :: State -> TmsState
